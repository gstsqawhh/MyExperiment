<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600986 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="969"/>
<h1>分布式锁的几种实现方式</h1>

<div>
<span><div><div><b><font style="font-size: 12pt;">一、目录</font></b></div><ol><li><div><font style="font-size: 12pt;">分布式锁的作用</font></div></li><li><div><font style="font-size: 12pt;">使用乐观锁实现分布式锁</font></div></li><li><div><font style="font-size: 12pt;">使用redis实现分布式锁</font></div></li><li><div><font style="font-size: 12pt;">使用redisson实现分布式锁</font></div></li></ol><div><font style="font-size: 12pt;"><br/></font></div><div><b><font style="font-size: 12pt;">二、分布式锁的作用</font></b></div><div><font style="font-size: 12pt;">在分布式系统中，不同的模块可能会处理相同的数据，或者同一个模块部署在多台机器上后肯定会处理相同的数据，此时为了保证这些数据更新的安全性，即操作的原子性，需要给这些操作加上分布式锁，这样更新相同数据的操作便会串行化地执行，保证了更新数据时的安全性。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><b><font style="font-size: 12pt;">三、使用乐观锁实现分布式锁</font></b></div><div><b><font style="font-size: 12pt;">1、乐观锁介绍</font></b></div><div><font style="font-size: 12pt;">顾名思义，乐观锁乐观地认为加锁会成功，它对加锁的保障在于会去判断加锁的结果，如果结果表示加锁失败，则会进行重试，可以看到乐观锁不适应并发量非常高的场景，并发量非常高的场景对锁的竞争强烈，此时如果应用乐观锁，则会造成客户端不断地重试，从而降低了吞吐量。</font></div><div><font style="font-size: 12pt;"><b>2、乐观锁实现</b></font></div><div><font style="font-size: 12pt;">以MySQL为例，对MySQL的表加乐观锁，一般会为表增加一个version属性或者timestamp属性，在每次读取数据进行更新时，也读取到version字段，在更新数据时，需要比较旧的version字段和当时表中最新的version字段，如果一致，则更新数据，否则更新失败，进行重试。</font></div><div><font style="font-size: 12pt;">这要求数据库将“先get到最新version进行比较，比较成功后进行更新”作为一个原子性的操作，如果数据库不支持该原子性操作，则不能完全保证更新数据库的安全性，因为有可能两个客户端在距离极短的时间内先后执行了get-compare-set操作，这样后执行的更新结果会覆盖先执行的更新结果。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>四、使用redis实现分布式锁</b></font></div><div><font style="font-size: 12pt;">1、通过redis实现分布式锁</font></div><div><span style="font-size: 12pt;">        redis是一个可以独立部署的key value式的缓存，redis中的setnx操作可以保证原子性地保存数据，并且在数据已经存在时，会返回保存失败，这可以用来加锁，当保存数据失败时，则证明已有其它客户端加锁成功，从而实现了加锁机制。</span></div><div><span style="font-size: 12pt;">        为了防止在分布式锁加锁期间，出现一些过于耗时的操作从而出现死锁，会为分布式锁设置一个超时时间，这可以通过redis的expire操作来实现，现有的redis client基本上实现了setnx和expire作为一个原子化操作的方法，一般设置为10秒及以下，在expire后，其它客户端可以继续加锁，为了避免超时的客户端在执行解锁期间删除掉其它客户端已经加上的锁，需要保证每个客户端在加锁时value是唯一的，一般采用uuid来实现。</span></div><div><font style="font-size: 12pt;">        </font><span style="font-size: 12pt;">解锁时，删除相应的key value键值对即可，为了保证保证解锁的原子性，一般通过脚本的方式来实现，这是因为在删除时需要删除特定的key value对，即先判断value为特定value，然后再去删除，否则有可能删除其它客户端加的锁，使用脚本可以尽量保证删除操作的原子性。</span></div><div><span style="font-size: 12pt;">代码示例如下：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class DistributedLock {</div><div><br/></div><div>    private RedisScript&lt;Integer&gt; unlockScript = RedisScript.of(</div><div>            &quot;local res = redis.call('get', KEYS[1])\n &quot; +</div><div>                    &quot;if (res == ARGV[1]) then return 1 else return 0 end&quot;);</div><div>    @Autowired</div><div>    private RedisTemplate redisTemplate;</div><div><br/></div><div>    public boolean lock(String key, String value, int expireSecond) {</div><div>        boolean res = redisTemplate.opsForValue().setIfAbsent(key, value, expireSecond, TimeUnit.SECONDS);</div><div>        return res;</div><div>    }</div><div>    public boolean unLock(String key, String value) {</div><div>        int res = (int) redisTemplate.execute(unlockScript, Arrays.asList(key), Arrays.asList(value));</div><div>        return res == 1;</div><div>    }</div><div>}</div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">        另外，为了在加锁失败时不立即返回失败，增加请求的成功率，一般会重试数次去尝试加锁，每次尝试加锁之间间隔一定的时间，如果重试10次，每次间隔50ms。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><b>五、使用redisson实现分布式锁</b></font></div><div><font style="font-size: 12pt;">redisson分布式锁实现了</font><span style="font-size: 12pt;">java.util.concurrent.locks.Lock 接口，使用很简单，包括加锁、加锁后一段时间自动释放锁，重试一段时间进行加锁等。</span></div><div><span style="font-size: 12pt;">而且redisson分布式锁还实现了</span> <span style="font-size: 12pt;">lock watchdog，在redisson实例崩溃时自动地释放锁，避免死锁。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>RLock lock = redisson.getLock(&quot;anyLock&quot;);</div><div>// Most familiar locking method</div><div>lock.lock();</div><div><br/></div><div>// Acquire lock and release it automatically after 10 seconds// if unlock method hasn't been invoked</div><div>lock.lock(10, TimeUnit.SECONDS);</div><div>// Wait for 100 seconds and automatically unlock it after 10 secondsboolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);</div><div>if (res) {</div><div>   try {</div><div>     ...</div><div>   } finally {</div><div>       lock.unlock();</div><div>   }</div><div>}</div><div><br/></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div></div></span>
</div></body></html> 